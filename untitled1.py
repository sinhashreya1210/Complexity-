# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EV--rpuFWToEmLRUXcIN98B2fVHVOOCA
"""

#  DAG of complexity classes as a dictionary
complexity_dag = {
    'ALL': ['EXP', 'Ppoly'],
    'EXP': ['PSPACE'],
    'PSPACE': ['P#P'],
    'P#P': ['PH', 'PP'],
    'PP': ['BQP', 'MA', 'coNP'],
    'PH': ['AM', 'coNP'],
    'BQP': ['BPP'],
    'Ppoly': ['BPP'],
    'AM': ['SZK', 'MA'],
    'MA': ['BPP', 'NP'],
    'coNP': ['P'],
    'NP': ['P'],
    'BPP': ['P'],
    'P': ['NC'],
    'NC': ['L'],
    'L': ['AC0']
}

#  DFS algorithm to search for the shortest path between two classes
def dfs_shortest_path(start_class, target_class, visited=None, path=None):
    if visited is None:
        visited = set()
    if path is None:
        path = [start_class]
    visited.add(start_class)
    if start_class == target_class:
        return path
    for child in complexity_dag.get(start_class, []):
        if child not in visited:
            new_path = path + [child]
            shortest_path = dfs_shortest_path(child, target_class, visited, new_path)
            if shortest_path is not None:
                return shortest_path
    return None

start_class = 'PP'
target_class = 'EXP'
shortest_path = dfs_shortest_path(start_class, target_class)

if shortest_path:
    print(f"Shortest path between {start_class} and {target_class}: {' -> '.join(shortest_path)}")
else:
    #print(f"No path found between {start_class} and {target_class}. Trying again with swapped start and target classes.")
    shortest_path = dfs_shortest_path(target_class, start_class)
    if shortest_path:
        print(f"Shortest path between {target_class} and {start_class}: {' -> '.join(shortest_path[::-1])}")
    else:
        print(f"No path found between {target_class} and {start_class}.")